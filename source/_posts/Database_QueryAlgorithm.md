---
title: 查询操作的实现与性能分析
abbrlink: db0b0d1b
date: 2021-12-10 12:21:03
---
# 查询操作的实现与性能分析
## 性能分析模型
高度简化的查询代价估计模型
- **只计算寻道时间和块传输时间**，不计算CPU时间
- 假设连续的记录存放在连续的盘块上。比如顺序访问一个表的所有块只需要寻道一次

## 选择运算性能分析
- 线性扫描
- 聚簇索引
  - 码列
  - 非码列
- 非聚簇索引
  - 码列
  - 非码列
- *哈希索引
- 范围选择运算

## 外排序：多路归并排序与性能分析
### 基于外存的多路归并
- 设有$M$块缓冲区可供排序使用。则
- 将归并操作中已经有序的连续块称为*归并段*
- 利用$M-1$个块实现M-1路归并
- 实际上归并段的数目通常远远不止$M-1$，因此需要分多次执行M-1路归并。所有归并段这样处理一遍就叫*一趟*
- M-1路归并生成的新归并段作为下一趟的输入

总结：算法如下：
1. Phrase 1 建立归并段
   
   也即读入每个块，每M个块排序形成一个归并段，然后写回外存

2. Phrase 2 多路分趟归并
   
   取$M-1$个块每块存一个归并段，余下一个块用于缓存输出。

   多趟执行归并之后只剩一个归并段，排序完成

### 算法分析

这里只分析IO

- 建立归并段阶段每个块各读写一次，块传输数$2b$，寻道数$2\lceil b/M\rceil$
- 初始归并段数目$\lceil b/M\rceil$
- 每一趟对所有段执行了M-1路归并之后，段数目变为归并前的$1/(M-1)$，因此总归并趟数$\lceil \log_{M-1}(b/M)\rceil$，每一趟所有块读写各一次，每个块
- 设最后一趟只读不写回，加上Phrase 1，最终块传输数（忽略边界情况）：
  $$
    b(2\lceil\log_{M-1}(b/M)\rceil + 1)
  $$

- 最终寻道数：
  
  $$
    2\lceil b/M\rceil + b(2\lceil\log_{M-1}(b/M)\rceil - 1)
  $$





## 连接运算性能分析
### Nested-loop join
```
for t_r in r:
    for t_s in s:
        if t_r.a == t_s.a: yield join_concate(t_r, t_s)
```
以下假设对于每个关系，缓冲区只能容纳一个块在内存中
- 块传输数：$n_r \cdot b_s + b_r$
  
  对每个$t_r$扫描传输整个$s$关系，故需要$b_s$传输次数。$t_r$顺序扫描，故只需要传输$b_r$块

- 寻道数：$n_r + b_r$
  
  内层顺序扫描$s$表，因此只需要一次寻道。

  外层虽然也是顺序扫描，但是中途内层肯定改了磁头位置，因此需要重新寻道，故读$b_r$块就需要寻道$b_r$次。

### Block nested-loop join
```
for B_r in r
    for B_s in s:
        for t_r in B_r:
            for t_s in B_s:
                if t_r.a == t_s.a:
                    yield join_concat(t_r, ts)
```

- 很接近朴素方法。但顺序扫描限定在了块内，因此节省了时间
- 块传输数：$b_r \cdot b_s + b_r$。节省时间是因为不需要每次扫到下一行就重新装入这个$s$表
- 寻道数：$2b_r$。节省时间的原理同上

- Index based join
- *Hash based join
