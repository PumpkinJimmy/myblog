---
title: 分布式系统的一致性
abbrlink: ebd44359
date: 2021-11-19 07:53:58
---
# 分布式系统的一致性

## 前言

以下讨论的一致性是狭义上的*进程*之间的一致性。

## CAP定理
CAP定理是指分布式系统中，Consistency（一致性）, Availability（可用性）, Partition tolerance（分区容错性）**不可兼得**
- 一致性：进程之间保持绝对的共识
- 可用性：任何时刻保证进程是可以正常服务的
- 分区容错性：（待完善）

实际中将不得不对这三个因素，尤其是C和A做权衡：
- 常见的事务系统（如银行）必须保证一致性，代价是会影响可用性（其实就是慢）

## 复制（Replication）

复制的目的：
- 性能
- **可用性**

复制的主要问题：**一致性问题**

保证副本之间的一致性所面临的挑战：
- 确保临界操作都要正确互斥
- **在所有副本之间的必须以相同的顺序执行临界操作**
- 保证全局一致性的代价太高，可能只能做到*最终一致性*
  
面临的临界操作冲突：
- 读写冲突
- 写写冲突
（注意：读和读之间是可以并发的，不存在冲突）

三个级别的一致性模型：
1. 连续一致性
2. 因果一致性
3. 最终一致性

## 以数据为中心的一致性模型

说明：一致性的度量是“结果导向”的。也就是说，我们说“一致性”就是说结果的数值是一样的。

### 一致标准：连续一致性

连续一致性：数据一致性的三个维度：
1. 数值偏差
2. 新旧偏差
3. 顺序偏差

因为绝对的一致性不可实现，实际系统中考察一致性的重要度量就是连续一致性的三个维度：我们能在多大程度上数据的差异我们可以容忍并视作是“等同的”

- 数值偏差
  
  这是最直观的情形。如果副本之间的某个数据对象具有“数值语义”，则**对象在副本中的绝对值偏差不超过容忍，则认为对象达成一致**

- 新旧偏差
  
  对于非数值语义的数据变量，我们认为**不太旧的版本的变量是一致的**

- 顺序偏差

### 一致的操作顺序
- 顺序一致性
  
  顺序一致性要求**在所有副本上，所有临界操作都以相同的顺序执行**

- 因果一致性

    因果一致性是弱化的连续一致性。

    因果一致性**只要保证Happen-before顺序成立，不要求每个副本上操作执行顺序相同**

### 分组操作（待完善）

## 以客户为中心的一致性模型：最终一致性

比因果一致性更弱的一致性的场景：最终一致性。

最终一致性的内涵：**如果系统一直没有修改，则数据的各个副本会逐渐变成一致**

最终一致性只要求系统**对于单个客户端自身的“视图”是一致的**，对分布式系统内部状态的一致性没有要求

说明1：以下说明中，强调*同一客户端*不意味着“同一个副本”。抽象而言，同一个客户端其实是指同一个身份，这个身份可能依赖某种标识手段。

说明2：我们在讨论写读一致性以及单调写时，都存在“写在后”的情况。此时由于没有配套一个读操作，好像写操作带来的“视图”的改变不可知。因此，讨论这两方面时，我们假设*存在一个上帝视角可以考察副本中一个对象的值“最终的取值”*

**单调读**：对同一个客户端来说，每次读取同一个变量，**不会得到比之前读的更旧版本的值**

**单调写**：对同一个客户端来说，**写操作的生效要保证按需生效（Happen-before顺序成立）**

**读写一致性(read after write)**：
- 对同一个客户端而言，**它的写操作总是在它之后的读取之前完成。写后读到的总是写后值**

**写读一致性(write after read)**：
- 对同一个客户端而言，**它的写操作至少基于最近一次读到的值生效（覆盖最近读到的值）**
- 违反写读一致性的例子：客户端A、B并发，初始$x=x_0$，客户端A写$x=x_1$, 客户端B先读$x$，再写$x=x_2$。此时，客户端读到的值、$x$实际的取值为$(x_0, x_1), (x_0, x_2), (x_1, x_2)$都是符合最终一致性的，但是若是$(x_1, x_1)$，则违反最终一致性。因为读到$x_1$之后，对于B而言，写$x_2$操作是后发生的，该操作应该覆盖$x_1$，但最终不满足这一点，因此不符合最终一致性。



## 复制管理
- 三类复制：
  - Permenant Replicas
  - Server-initial Replicas
  - Client-initial Replicas
- 更新模式：Push vs. Pull
  - Pull 适合大规模、大量客户端的系统（成本更低），但是需要主动拉去更新
  - Push 成本更高，但可以同步更新
- 折中的更新模式：Lease（租约）
  - 在Push和Pull之间动态切换
  - **在Lease有效期内对象是基于Push更新的；过期之后就切换为基于Pull的**
  - 自适应指定Lease的策略同样有多种


## 一致性协议（待完善）