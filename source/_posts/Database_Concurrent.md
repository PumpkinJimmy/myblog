---
date: 2021-12-20 10:08:06.486421+08:00
title: 事务并发控制

---
# 事务并发控制
## 基于锁的协议
两种锁：
- exclusive mode(排他模式): 加锁后其他并发事务对数据项*不可读不可写*，对应的锁是*lock-X*(排他锁)
- shared mode(共享模式): 加锁后其他并发事务对数据项*可读不可写*，对应的锁是*lock-S*(读写锁)

锁需要向*并发控制器*发出请求

### 锁兼容

不同事务可能对同一数据项加锁，多个锁之间存在锁兼容问题。对于两种锁，一共四种情况，**只有lock-S + lock-S是允许的**。其余情况下（只要包含排他锁），多次加锁都会阻塞。

### 死锁

这种排他锁显然可能导致死锁。

锁协议中死锁是不可完全避免的。


### 饥饿

一但出现死锁，DBMS默认的行为是回滚。*由于反复回滚，事务一直得不到执行*，就是饥饿。

锁协议中死锁是不可完全避免的。


### Two-phase Locking Protocol(两阶段封锁协议)
- **整个事务分为两个阶段（Phase）**
- Phase 1: Growing Phase

  **只能申请锁，不可释放锁**

- Phase 2: Shrinking Phase

  **只能释放锁，不可申请锁**

- 两阶段封锁不是说所有的`lock/unlock`必须挤在一起，而是指*不允许交错`lock/unlock`操作*
- strict two-phase: 在two-phase基础上，**要求事务保有所有排他锁一直到提交才释放**
- 强two-phase: 在two-phase基础上，**要求事务保有所有锁一直到提交才释放**

#### 锁转换

为了调高并发效率，我们允许*锁转换（lock conversion）*：允许从lock-S提升到lock-X，或者从lock-X降级到lock-S

同时，扩展two-phase locking protocol:
- Phase 1允许lock upgrade
- Phase 2允许lock downgrade

#### 锁实现

主要讨论锁机制以及锁管理器的实现。

存在哈希表实现的*锁表*记录每个记录中获得锁、等待锁的事务

### Graph-based Protocol 基于图的协议

这个协议保准不会死锁，却依赖关于访问顺序的偏序信息，非常不实用，因此不合理。

一种简化的是协议是Tree Protocol树协议: 在lock某个节点对应的记录之前，必须先lock它的父亲

### 死锁处理
- 死锁预防：
  - 一次性申请
  - 顺序申请资源
  - 可抢占：强行抢占资源，被抢占的事务回滚（可能导致饥饿）
  - 基于超时：超时就认为死锁了，然后回滚

- 死锁检测：
  - *周期性*检测等待图
  - **一但等待图中发现了循环等待，则将涉及的事务回滚**