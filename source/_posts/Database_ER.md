---
date: 2021-10-13 14:22:53
---
# 数据库E-R模型

E-R模型（Entity-Relation）是用于设计、表示数据库的**概念模型**的建模工具。

E-R模型使用的语言是UML。

E-R模型中只有两种节点：
- *实体集*：带标题的方框
- *联系集*：菱形方框

E-R模型设计的主要目标有：
- 消除冗余
- 表达约束

## 实体集
是现实世界中对象的抽象表示。

实体由如下内容构成：
- 实体名
- 属性

注意，**实体必须包含主键**（例外是弱实体）

## 关系集

关系是现实中事物联系的抽象表示。

通常联系只有名称。

也可以通过一个虚线+方框拓展出属于联系集的属性。

### 属性形态

属性的形态：
- 单值属性：对标基本类型
- 组合属性：对标结构体
- 多值属性：对标数组
- 计算属性：对标Getter函数

注意上述形态是可以继续符合的，比如说多值组合属性（结构体数组）。


## 映射基数约束

可以理解为关系“一对一”，“一对多”，“多对一”之类的约束。

这一约束会决定最终转化出来的表的设计。

### 角色（Role）

一种特殊的联系是*自相关联系*，即属于同一实体集的实体之间存在联系，表现在图上为一个实体集合连了多条边到同一个联系集。

### 完全参与

给定实体**至少存在一个到另一实体的某联系**，则成为该实体*完全参与*了该关系

### 弱实体

有些实体不指明主码，称为*弱实体*。

不指明主码的原因是弱实体**从属与某类实体，它关于该类实体的某一实例才是可区分的**。

此时，**弱实体必须对应存在一个完全参与的关系，来描述区分它的实体**，且此时这个特殊的关系称为*Identification Relation*，这个实体就是*Identification Entity*

## ER模型到数据库模式的映射

概念模型到数据库模式的映射是概念模型实现的关键。

单每个Entity,Relation分别对应一个表的粗糙的映射不足以产生最合适的模型。

实际上，这样的映射会产生错误的表主键选择以及冗余的表，还不能处理形态多样的属性。**E/R都不可简单对应于一个表**

以下详细讨论。

### 基本情形
- 一个实体集对应一个表，表属性就是实体集属性，表主键就是实体集主键
- 一个联系集：
  - 对应一个表
  - **表属性是参与联系的实体的主键 + 联系集自己的属性**
  - 可以没有主键
  - **来自实体的主键属性存在参照实体表的外键约束**

### 完全参与联系

完全参与联系对应到一个非空外键约束。

### N对1联系

N对1联系不需要单独对应一个表。

这样的联系对应的是联系中唯一的那个参与实体集的一个属性。

### 弱实体

弱实体没有主码，所以在实际建表的时候：
- 弱实体表的属性是**自己的全部属性 + Identification Entity的主码**
- 弱实体表的主码是**表的全部属性的集合**

### 组合属性

组合属性直接展平为多个单值属性即可。

### 计算属性

在表设计部分直接无视掉计算属性。

计算属性不会存储，不会作为物理表的一部分出现，但有可能作为视图属性，或者SQL过程存在。

### 多值属性

多值属性的麻烦在于：实体元组是定长的，不适合存储变长数组这样的属性。

这导致我们不得不单开一个表来处理多值属性。

具体来说：
- 实体表中不出现多值属性字段
- 为多值属性单开一个表
- 该表只有两个属性：**从属实体的主码和本身的值**
- 该表的主码是该表的所有属性的集合

一些很特殊的实体，只有自己的主码和一个多值属性。此时处理如下：
- 不再为这个多值属性单开一个表
- 原实体的主码不再是表的主码，而是根据实际情况选择
  
  重新选择主码的理由是，此时实体表兼任了多值属性的变长数组的物理表。原本唯一的实体主码会因为同一实体的多个数组元素记录而在表中重复。一种总是正确的选择是“以全部属性的集合作为表的主码”。

## 常见错误
- 将一个实体集的主码作为另一个实体集的属性
  
  这种设计的错误在于**将两个实体集之间的联系表达为了属性这样的隐含关联，而不是联系集这样的显式关联**

- 将一个实体集的主码作为一个联系集的属性

## ER设计中的权衡
- 属性 vs. 实体
  
  一些属性（尤其是多值属性）可以建模为一个单独的实体配合一个联系

  此时涉及的是*抽象的粒度*的问题。
  
  具体选择取决于需求。

  比如说，将原本的属性建模为实体之后，该实体可以与其他实体产生联系。而原本作为属性则不行。

- 带属性的联系 vs. 专门的中间实体
  
  一些带属性的联系可以等效建模为一个单独的中间实体，配以中间实体的新联系。
  
  同样是抽象的粒度问题。

  具体选择取决于需求。

- 联系的属性 vs. 实体的属性
  
  有时联系的属性可以单独建模为实体的属性。

  为了设计清晰，通常不建议这样做，且这种迁移只适用于对单联系。

- 二元联系 vs. 多元联系

  显然一个多元联系可以拆分为多个二元联系。

  原则性的建议：
  - 只在特别合适的时候使用三元联系
  - 不使用超过三元的联系



## 扩展ER模型特性（待完善）
### 特化（继承）
依赖特化，我们给出了实体集与实体集之间更具体的约束：
- 特化实体是泛化实体的超集
- 可以约束不同特化实体之间没有交集

这些约束可以厘清实体集自然连接的语义：
- 泛化实体与特化实体的自然连接的语义其实是*扩增属性*
- 两个没有交集的特化实体集之间做自然连接不会返回任何结果

### 完整性约束

### 聚集
用于表达*关系与关系之间的关系*