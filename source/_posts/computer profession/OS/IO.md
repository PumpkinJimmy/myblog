---
title: IO
tags:
  - 专业课
abbrlink: 8601bab2
date: 2021-06-23 00:17:40
updated: 2021-06-23 00:17:40
---
# IO与设备管理
- 设备的控制器需要完成串并转换。因为通常物理设备都是面向*比特流*的串行数据，但是计算机中的数据都是并行传输的（以字/字节为单位）
- 常见IO控制方式：
  - 程序IO控制：同步IO，忙等待
  - 中断驱动IO：异步IO，让权等待
    
    中断驱动IO的本质是利用外部中断**异步通知处理器**

  - DMA：由专门的DMA模块控制内存和IO设备之间的数据交换
    
    DMA是对中断驱动IO的改进。

    中断驱动IO可能需要支付较大的额外开销：以键盘为例，每次按键产生一个扫描码，都会触发一次中断。大量按键会触发大量的中断。而系统中断是有一定的开销的（上下文切换、中断处理程序、清空流水线、处理器指令级并行的损失）。

    在DMA方式的IO中，**处理器只需要发送IO命令和IO所需的信息，IO设备与主存之间的数据传输由DMA控制器完成，不占用处理器**。
    
    此外，**仅在数据交换完成的时候才触发一次中断通知处理器**。这区别于中断驱动IO。中断驱动IO中，IO设备每次准备好了以后通过中断通知CPU，CPU负责在收到通知后发送IO命令将数据从IO设备的缓冲区传输到主存中。在DMA控制的IO中，IO设备每次准备好后由DMA负责将数据从设备缓冲区传输到主存中，全部传输完成了才通知中断通知处理器。

    DMA需要利用处理器和主存之间的数据总线，利用空余的时间代理CPU完成数据传输控制。

  - 更进一步的技术：IO通道，IO处理机（大规模IO密集型计算机上的技术）
    
    IO通道/IO处理机是DMA的发展，这些部件具有更高的自主权，具有更高的效率。（比如，IO通道可以自主决定输入信息放置在内存中的位置。）

    IO通道/IO处理机都是硬件设备。

- IO软件设计目标
  - **效率**
    - 通常IO设备比主存慢4个数量级以上
    - IO在许多系统中是性能瓶颈
  - 通用性
    - 对异构的IO设备提供统一的抽象和接口
    - 已有的成功案例：Linux的*Everything is file*，将一切设备都抽象成文件提供统一的接口（read,write,open,close）
- IO系统架构
  - 用户层
  - 设备无关层
  - 设备驱动程序
  - 中断处理程序
  
  注意：
  - 用户层是直接暴露给用户的IO接口；
  - 设备无关层主要是将设备无关的用户层请求和参数针对具体设备做转换，转换为设备驱动程序可以处理的形式
  - 设备驱动程序是通过读写IO端口直接控制设备的硬件相关软件，它可以为内核提供相对统一的读写命令，屏蔽硬件细节。现代OS的设备驱动常运行在一个系统服务进程中，它实质上是用户进程与IO设备的通信进程。
  - 中断处理程序，它是硬件通知处理器的通信程序，与硬件紧密关联。
  - 上述三层由高到低。
  
- SPOOL假脱机技术
  
  计算机体系结构从高速到低速：
  CPU(ns) - Cache(10ns) - Memory(us) - Disk(ms) - Printer/Other(s)

  类似打印机一类的IO设备对OS的IO软件系统提出了新的问题：
  - 打印机比机械磁盘还要再慢一个数量级
  - 打印机是*独占设备*，原则上同时只能由一个进程进行打印机IO

  SPOOL假脱机技术解决了上述两个问题。

  SPOOL技术要点
  - 所谓“假脱机”其实是“假脱机，真联机”。脱机/联机是来自旧时代计算机系统的术语，在现在可以对标术语异步/同步。在以前，计算机系统联机使用IO设备是需要忙等待设备完成工作才能继续往下工作的。而脱机工作则不用等待，有专用的外围机器负责控制IO设备，上位机只需要交付工作命令即可。但脱机工作是由操作员手动完成的，也需要专门外围设备，是已经过时的实践。而**SPOOL的思想正是在实际上联机的体系结构上实现过去脱机操作才具备的让权等待的异步IO特性**
  - 由于（打印机之类的）慢速IO设备比处理器慢太多了，忙等待慢速IO设备是不明智的。因此**SPOOL利用主存中的输入/输出缓冲区和（机械硬盘一类）高速IO设备中的输入井/输出井来解决速度不对等，免除忙等待**
  - **SPOOL还是一种虚拟IO设备技术。**单处理器多道程序系统可以看作将一个系统一个物理CPU虚拟出多个逻辑CPU提供给多个进程并发使用的技术。同样，**SPOOL可以实现将一台独占的IO设备虚拟出多台逻辑IO设备供多个进程并发使用的技术。**实现的关键同样是输入输出缓冲和输入井输出井。不同进程只需要通过统一的IO软件发出IO指令，系统IO软件读写并管理磁盘的井而不是直接读写打印机的端口，从而实现多个进程复用同一台独占IO设备。

- IO设备分类：按存取
  - **面向块的设备(block-oriented)**：支持随机访问一块固定大小的数据的设备。对应Linux中的块设备。典型的块设备是硬盘。
  - **面向流的设备(stream-oriented)**：只能逐字顺序存取的设备。对应Linux中的字符设备。典型的字符设备有键盘（逐个扫描码输入）和打印机。

- IO缓冲区
  - 缓冲的主要动机
    - 处理器与IO设备处理速度差异过大
    - 由于虚拟分页，有时IO本身会干扰OS的交换决策，还有可能造成一些死锁
  - 缓冲的主要限制：无法突破IO外设本身的性能上限（依然造成瓶颈）
  - 虚拟分页 + 挂起造成的“单进程死锁”
    
    考虑虚拟分页系统中的一种情景：进程发出IO指令后挂起并换出进程影响，IO操作完成后要将数据写入进程的数据区。此时产生一种**循环等待**：进程等待IO完成后换入并唤醒；IO等待进程映像换入并写入数据区。
  - 缓冲类别：
    - 单缓冲
    - 双缓冲
    - 环形缓冲
    - 缓冲池
- 单缓冲
  - 性能分析：
    
    令IO用时$T$，CPU处理用时$C$，缓冲区数据载入内存用时$M$，则一次IO处理总用时：
    $$
      \max(T,C) + M
    $$

    这是因为单缓冲区允许处理器处理缓冲区载入内存的数据的同时IO设备同时运行下一次IO操作（也成为*预读*）。

    但由于IO设备和用户进程无法共享缓冲区，因此在一次IO完成后需要等待将缓冲区数据拷贝到用户空间。

- 双缓冲：缓冲区交换
  - 对字符设备与单缓冲没有区别
  - 对块设备，相比单缓冲有改进
  - 性能分析（以写入为例）：
    
    令IO用时$T$，CPU处理用时$C$，缓冲区数据载入内存用时$M$，则一次IO处理总用时：
    $$
      \max(T,C + M)
    $$

    因为双缓冲区允许在**IO设备在缓冲区1写入完成后，不必等待缓冲区1的数据拷贝到用户空间，而是立即切换到另一个缓冲区2来进行下一次的写入。**此时一次IO完成后填满的缓冲区1可以与IO设备并行地进行拷贝操作。等第二次IO完成，又将使用完的缓冲区1交给IO设备使用，用户处理缓冲区2的数据。

    从双缓冲的操作流程可以看出，若缓冲区拷贝到用户空间+用户程序处理的时间比一次IO要小，则IO设备可以不停止地全速读取和写入缓冲区，此时IO设备利用率接近100%了。

- 缓冲 vs. 缓存
  - 它们都有助于提高系统效率和性能
  - 缓冲强调“缓”，也称“暂存”，核心功能是**缓解设备处理速度的差异，平滑数据流，提高设备的利用率**。
  - 特别地，对于流设备，缓冲模型一般是队列（生产者-消费者）
  - 缓存强调“存”，也称“高速缓存”，核心功能是**将低速设备的数据存放在高速缓存中，减少对低速设备的访问频率，提高高速设备性能**。高速缓存强调“命中率”。
  - 多数缓存都依赖某种索引结构，要求高性能的查找/修改操作。
  - 缓冲改进性能的原理是**允许高低速设备并行运行，高速设备不必忙等待低速设备**
  - 缓存改进性能的原理是**减少高速设备低速访问的操作次数**
  
- 缓冲区的两个常见使用：
  - *预读*：常见于读大量盘块的情景，每读到一个块的数据写入缓冲区，处理程序就可以立即访问缓冲区来处理数据，处理程序运行的同时IO设备可以并行地进行下一个块的读入，不必等待。预读的效果很好，它尽快地启动了IO，而代价仅仅是最后可能多预读了一个块。
  - *滞后写*：对设备的写操作不是立即执行，而是先写缓冲区，再在合适的时候将缓冲区中的数据写入外设。这种操作能提高IO性能，代价是增加了维护数据一致性的复杂性。

- 磁盘调度
  - 动机：磁盘访问最大的延迟来自于**寻道**（沿盘片半径移动磁头到某一磁道）。磁道的单次寻道时间很难减小，但可以通过适当地重排磁盘请求顺序，减小磁头寻道的总距离，从而减小平均寻道时间。
  - 常见策略：（待完善）
    - FIFO
    - 优先级
    - LIFO
    - 最短服务时间优先
    - SCAN & C-SCAN（电梯算法）