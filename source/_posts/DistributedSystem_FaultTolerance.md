# 容错
## 含义
容错容许系统的*某些*组件失效，而不会*严重*影响整体性能。故障发生时，系统可以进行*恢复*，同时可以继续任务处理。能够容错的系统是*可靠的*（广义）。

## 要求

广义上的可靠性包含如下四个方面：

- Availability 可用性
  
  系统是否准备好提供服务

- Reliability 可靠性
  
  系统持续提供服务的能力（持续运行能力）

- Safety 安全性
  
  低概率发生灾难（宕机、数据损坏、数据泄露）

- Maintainability 可维护性
  
  一个失效的系统修复的能力

## 容错性相关度量
可靠性度量：
- 平均失效时间（MTTF）：直到组件失效的平均时间
- 平均恢复时间（MTTR）：恢复一个组件的平均时间
- 两次失效的平均时间（MTBF）：MTBF = MTTF + MTTR

可用性度量：
- 可用性考察的是某时间点上系统是否可用

## 失效的分类
- Crash Failure
- Omission Failure
- Timing Failure
- Response Failure
- Arbitrary Failure

## 分布式共识
### 与一致性的区别
- *共识*的要求比较明确：所有节点**对某些操作的认识保持一致**
- 一致性是更广义的概念。它存在多种模型，可能只要求数据（结果）一致甚至最终一致就可以了，不一定要操作一致。
- **共识是比一致更强的要求；若达成共识则必然成立一致**
- 共识协议的开销更大，性能更低，只有最重要的部件才需要共识；其他部分可以用要求更低的一致性。

### 与K-容错的区别
- K-容错问题中假设**对一个分布式系统操作/对象存在正确的结果**，可以简单地运用投票来解决
- 共识中*不一定存在一个正确的结果*，它要求**对等节点之间通过协商达成一致的状态**。

### 共识协议分类
- “停止失效”容错（无恶意行为）
  - 泛洪：适用于**能准确检测停止失效**的情景
  - Paxos, Raft：无法准确检测失效
- 有恶意容错
  - 拜占庭容错
  - 选举

### 基于泛洪的共识
- 只适用于**能够准确检测停止失效**的情景
- 适用的大前提隐含了一个非常强的条件：**系统是全局同步的**
- 由于系统是同步的，只需要timeout就足以探测出节点是否停止失效了

## Paxos
### 简介
适用非常广泛的实际系统的共识协议，前提非常宽松

特性：
- 适用异步系统
- 适用于通信不可靠，消息丢失、重复、乱序的系统
- 适用于进程会Crash Failure的情景，但不是任意型的失效
- 适用于无恶意行为的系统
- 可以检测出损坏的消息
- 所有操作都是确定的，即操作一旦执行，其行为可以被准确捕获

## 拜占庭容错
BFT最重要的特性是适用于**有恶意行为**的情景

### BFT

### PBFT

改进了朴素的BFT算法，更高效，适用于异步系统

## 再看CAP
结论：在通信失效的网络环境中，实现一个具有原子读写的共享内存同时又保证每一个请求得到响应式非常困难的。

- 通信失效对应 Fault Tolerance
- 原子读写对应 Consistency
- 每个请求都得到响应对应 Availability

失效是无法避免的现实困难。在有限的物质条件下，只能在Consistency和Availability之间做权衡：
- 要么为了保证一致性牺牲可用性（也就是要等，比如银行业务）
- 要么为了保证可用性牺牲一致性（比如互联网产品的业务，宁可存在暂时的不一致，也要保证可用和响应、避免等待）

## 故障检测
检测故障的核心手段是**timeout**机制。

timeout要起作用，必须假设系统是不完全异步的（至少请求的响应时间存在明确上限），而这往往不够好。

**timeout不够好，但目前很难做得更好**

## 可靠C-S通信
### 可靠RPC
错误类型：
- Unable to locate sserver
  
  可能原因：服务器关闭、更新

  解决方法：生成报错信息

- Request Lost
  
  可能原因：网络问题

  解决方法：“超时重传”

- Server Crash
  
  两种情况：执行后宕机、执行前宕机

  解决方法：没有很好的方法
  - 若采用重传（*At least once*），可能会导致**重复执行**
  - 若不做处理，直接报错（*At most once*），避免了重复执行
  - Exactly Once: Impossible to guarantee
  
  结论：**完全透明的服务器恢复（Exactly Once）是不可能的**

  一些可能的方案：设计*幂等*的接口。这可以保证**重复多次相同操作与一次操作的效果相同**。一般幂等的操作是：
  - 读操作
  - 严格的写覆盖操作

## 可靠多播
- 此处说的可靠说的是**允许不可靠的信道**，而不是**允许系统存在失效节点**
- 朴素的可靠多播
- Gossip
  - 简单
  - 速度慢，概率可靠
- 容错：原子多播
  - 多播的原子性：要么发给所有进程，要么不发给任何进程
  - 难点：组成员的变化
  - 实现：虚拟同步可靠多播协议

### 各种多播汇总
(TO = Total order)
| Multicast               | ordering       | TO delivery ? |
| ---
date: 2021-12-01 16:27:55.422574+08:00
title: 容错

-------------------- | -------------- | ------------- |
| Reliable multicast      | None           | No            |
| FIFO multicast          | FIFO-ordered   | No            |
| Casual multicast        | Casual-ordered | No            |
| Atomic multicast        | None           | Yes           |
| FIFO atomic multicast   | FIFO-ordered   | Yes           |
| Causal atomic multicast | Causal-ordered | Yes           |

说明：
- 所谓的FIFO是指**对于某一信道/Sender而言，先发的消息先收到**
  
  FIFO与Total Order的差距在于**一个Receiver会接收来自不同Sender的消息，此时两个信道之间的消息的相对顺序不一定相同**

- 所谓的Casual是指**对于存在Happen-before（因果）关系的消息，“因”消息比“果”消息拍得更前**
  
  Casual与Total Order的差距在于**许多消息并发不存在因果约束，在不同Receiver上顺序可能不同**，比如两个进程各自发送消息，它们之间如果没有通信，那它们发送的消息通常就不存在因果依赖了。

- 所谓Atomaic其实是要求**所有的节点收到的消息序列相同（包含消息集合相同和消息顺序相同）**，也即*全序一致（Total order delivery）* 。其中不要求顺序是否FIFO或者Casual，强调节点之间的一致

## 分布式提交
- 比原子多播更高的要求：系统所有节点（**包括可能失效的节点**）以相同的顺序执行相同的操作
- 因为要保证可能失效的节点也要执行相同的操作，因此**系统单点失效会导致正常节点阻塞**。实际系统中不可能无限地等待，最终结果是：因为超时失效，节点都不执行操作

### 两阶段提交（2PC）
基本思路都是：
1. Coordinator发起投票
2. 大家一致通过，即大家都同意提交，则操作生效
3. **任何一个节点投反对票，或者任何一个节点没有投票，都认为不提交**

核心思想是：**同意提交需要全票通过，不同意提交只需要一票否决**

状态机（待完善）：

失效恢复（待完善）：

2PC的问题：可能被阻塞

### 三阶段提交（3PC）

## 系统恢复

恢复的两类模式：
- Forward error recovery: 找到一个**新的正确的后继状态**
  - 典型的例子是纠删码
- Backward error recovery：**回滚到上一个没有错误的状态**
  - 更常见
  - **需要回滚就需要日志**

### Checkpoint 检查点
- Happen-before Checkpoint轴（待完善）
- 基于Coordinator的全局Checkpoint
  - 方法：类似2PC分布式提交，请求各个节点保存checkpoint
- 无Coordinator
  - 只能自己保存
  - 然后互相协作

### Message Log 消息日志
- 检查点代价偏高
- 另一种可行的恢复方法是借助消息日志*重放(Replay)*操作
- 重放的问题在于**对于非幂等的操作（典型的如新建），重复操作会带来不一致**

#### 日志记录方式
- 孤儿消息
- 悲观协议：必须等待一个不稳定的消息被日志记录才能发送下一个消息
- 乐观协议：回滚依赖消息（Replay依赖消息）