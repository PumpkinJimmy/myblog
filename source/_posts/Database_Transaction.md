---
title: 事务
abbrlink: 93ac284c
date: 2021-12-13 02:12:45
---
# 事务
## ACID
ACID = Atomic, Consistency, Isolation, Durality

- Atomic 原子性
  
  事务中的操作要么都执行，要么都不执行

- Consistency 一致性
  
  操作前后状态一致。

  并发不会导致竞态问题。

- Isolation 隔离性

  事务之间互相不干扰。

  如果允许事务并发，那数据库的所有数据都可以被认为事务的“全局变量”。但事务不像通常的进程需要自己处理互斥和同步，而是保证采用某种手段保证互相不干扰。

  从互相不干扰的角度看，隔离性也意味着**事务之间互相感知不到其他并发事务的存在**

- Durality 持久性
  
  事务一但完成，就永久生效。基本出现故障，也保证可以恢复

## 事务状态
1. Active 事务正在执行
2. Partially committed 部分提交：事务的最后一句执行完，但还未提交
3. Failed 出现错误
4. Aborted 出现错误，回滚之后的状态。此时：
   - 事务可能会重启
   - 事务可能最后终止
5. Committed 事务提交

Why partially committed:
- 在正式提交之前，事务执行的结果都是**暂存在内存而不是立刻写入到外存中**
- 暂存在内存中的状态就是*paritially commited*

## 事务调度
由于隔离性的要求，数据库系统必须为用户解决事务并发的互斥与同步问题。

必须通过合理的调度策略来保证事务并发的隔离性

### 串行调度

> 解决不了问题就解决提出问题的人

解决不了并发就不并发。**不允许事务并发即可根除事务互斥同步问题**

缺陷是效率低。

### 并发调度

保证并发调度正确的思想其实是
- *自动发现临界操作,对临界操作互斥并串行化,对其余操作并发*
- *自动发现数据关联,采用合理的串行顺序避免相互依赖带来的影响*

- 可串行化
  - 两种串行化: conflicting serialization, view serialization
  - 简化的分析模型:剔除事务中的其他操作,只保留读和写操作
  - conflicting instrucions:
    - 不同变量可以并发
    - 同一变量读读可以并发.
    - **同一变量的读写和写写相互冲突**
  - conflict serializability 冲突可串行化
    - **对非冲突的指令做交换可以得到相同的等价的操作序列**
    - conflict equivalent: 通过对非冲突指令交换指令顺序后得到相同的指令执行序列,则称为*conflict equivalent*,冲突等价
    - **如果一个调度执行序列与串行调度执行序列是冲突等价的**,则称这样一个并发称为*conflict serializable*(冲突可串行化)
  - view serializability
    - 弱化的可串行化
    - 只需要*视图*等价
    - 结论: 冲突可串行化的序列一定视图可串行化,反之不成立
    - 一个view serializable却不成立conflict serializable的典例是*blind write*(盲写)

  - 测试串行化的正确性
    - 优先图
    - 冲突可串行化等价于优先图无环
    - 冲突串行化算法:拓扑排序
    - 视图串行化问题: NPC

- 可恢复调度
  - 考虑一种事务并发调度情景: 事务A访问了另一个事务B处理过的变量,并在B还未提交之前率先提交. 此时, **一旦另一个B回滚,则A的结果可能不正确**.此时,这种调度称为*不可恢复调度*
  - 正确的调度应该是*可恢复的调度*. 以上面的例子说明,调度器务必通过延迟B的提交来保证即便A回滚,结果也是正确的

- 无级联回滚调度
  - 正确的调度应该是*无级联回滚*
  - 如果调度串行化之后,并发事务对同一个变量存在级联的读写依赖,则**初始处理变量的事务回滚会导致后继依赖事务全部级联回滚**
  - 定理:无级联回滚调度必然是可恢复调度