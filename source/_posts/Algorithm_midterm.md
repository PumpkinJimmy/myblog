---
title: 算法设计与分析：期中梳理
abbrlink: 8b00f71
date: 2021-10-31 16:05:14
---
# 算法设计与分析：期中梳理

## 分治法

### 分治乘法

$$

    T(n) = 3T(n/2) + \Theta(n)\\
    \Rightarrow T(n) = \Theta(n^{log_{2}3})
$$

## 强连通分量

### 定义
- 强连通：$u到v有路径 \leftrightarrow v到u有路径$
- 强连通分量(SCC)：极大强连通子图
- 强连通图：只有一个SCC的图
- SCC的根：SCC在缩点DFS生成树中的第一个节点

### 性质
- SCC问题可以等效为一个关于顶点的等价关系问题：**有向图中的任意顶点会且只会属于一个SCC**
- $v$是SCC的根当且仅当`LOW[v] == DFN[v]`

### 算法
大致如下：
```
cnt = 1

PROCEDURE findSCC(G)
    FOR v in G.V:
        IF used[v] == false:
            dfs(v)
    END
END

PROCEDURE dfs(v)
    dfn[v] = cnt
    cnt++
    low[v] = dfn[v]
    used[v] = true
    stack.push(v)
    FOR <v, w> in G.E:
        IF not used[w]:
            dfs(w)
            low[v] = min(low[v], low[w])
        ELSE IF dfn[w] < dfn[v] and w in stack:
            low[v] = min(low[v], dfn[w])
        END
    END
    IF low[v] == dfn[v]
        find SCC; pop until v;
    END
END
```

说明：可以证明，关于`low[]`的操作是正确的：直接排除横插边是对的。

### 应用
- 缩点
- 确定有向图中是否含有向回路


## 双连通分量

### 定义
- 割点：在无向图中，若去掉该顶点以及与该顶点相连的边之后，图中连通分量增多，则该顶点是割点
  
  推论：**顶点数小于3的图中不含割点**

- 割边（桥）：在无向图中，若去掉该边之后，图中连通分量增多，则该边就是割边
- 点双连通性：图中任意三个$u,v,w$，存在$u$到$v$的不含$w$顶点的路径则称图是点双连通的；
  
  等价定义：**不含割点的图是为（点）双连通图**
  
  推论：**定点数小于3的图都是点双连通的**

- 边双连通性：略
- 双连通分量(点双)：极大双连通子图

### 性质
- **顶点数小于3的图中不含割点**
- **定点数小于3的图都是点双连通的**
- 点双问题可以等效为一个关于**边（而不是点）** 的等价关系问题：**任意一条边会且只会属于一个点双**
- 一个顶点可以属于多个点双。这样的顶点一定是割点。
- 点双的缩点比较复杂，涉及点的分裂。因为若割点属于多于两个点双，若试图使用顶点来代表点双，那点双之间的关系无法直接使用边表示，需要对这样的割点单独用一个点

### 算法

有点像SCC的Tarjan算法：
```
PROCEDURE dfs(u)
    used[u] = true
    dfn[u] = low[u] = cnt
    cnt++
    FOR <u, v> in G.E:
        IF v != fa[v]
            fa[v] = u
            stack.push(<u,v>)
            IF not used[u]
                dfs(v)
                if (low[v] >= dfn[u])
                    find BSC
                    pop stack until pop <u, v>
                low[u] = min(low[u], low[v])
            ELSE
                low[u] = min(low[u], dfn[v])
                
    IF low[u] == u:

END
```
说明：
- 与SCC Tarjan最大区别在**SCC中我们在根顶点`low[u] == u`的时候一次产生一个SCC，但在BSC中我们必须每一分支都及时处理，因为当前点若是割点，则它可能涉足了多个BSC，每个孩子可能都带来一个新的BSC**

### 应用
- 无向图的点双与其简单回路密切关联
- 若图中边数与点双数目相同，则该图不含回路（虽然其实有更简单的判别算法）


## 顺序统计量
### 介绍
在顺序表上寻找第k大的朴素做法是先排序，再索引，时间$O(n\log n)$

但找最大、最小元素却是$O(n)$时间的

可以证明，寻找任何顺序统计量（第k大）的时间都是$O(n)$

### 随机选择算法

```
PROCEDURE kth_random(arr[1..n], k)
    p_idx = partition(arr)
    IF p_idx == k:
        return arr[p_idx]
    ELSE IF p_idx > k:
        return kth_random(arr[1..p_idx-1], k)
    ELSE:
        return kth_random(arr[p_idx+1..n], k - p_idx)
END
```

期望时间：$T(n) = T(n/2) + O(n) \Rightarrow T(n) = O(n)$

最坏时间：$T(n) = T(n-1) + O(n) \Rightarrow T(n) = O(n^2)$

### Median of median

“中位数之中位数”算法可以在$O(n)$时间内找到第k大

```
PROCEDURE kth(arr[1..n], k)
    FOR arr的5元素区间i
        m[i] = 区间内元素的中位数
    END
    pivot = kth(m[1..n/5], n/10)
    p_idx = find_rk(arr[1..n], pivot)
    IF p_idx == k
        return pivot
    ELSE IF p_idx > k
        return kth(arr[1..p_idx], k)
    ELSE
        return kth(arr[p_idx+1], k-p_idx)
END
```

时间：
$$
    T(n) = T(n/5) + T(3/4n) + \Theta(n)\\
    \Rightarrow T(n) = O(n)
$$

## 二分查找的平均查找长度（待完善）

## 基数排序

### 算法
基数排序的主要细节（以升序为例）：
- 对于等长关键字的排序，遵循原则：
  - 按照从后往前的关键字排序
  - 每一趟排序中，都是用顺序表做桶+桶内链表的模式来做。排好之后顺序收集链表串在一起得到下一趟的队列
  - 前一趟排序的结果队列不要打乱，作为后一趟的基础
- 对于不等长关键字的处理：
  - 从最长关键字开始排
  - 每一趟开始排序前，把长度刚好够的关键字集合插入到队列开头（这样做保证对应字段没有内容的关键字排在最前面
- 适当的预处理可以减少多余的扫描操作（尤其在不等长关键字排序中）


基排的时间复杂度：
- 等长：$O((n+m)k)$，其中$n, m, k$分别是关键字数目、关键字值域和关键字分节数。
- 不等长：$O(L + m)$，其中$L$是所有关键字长度之和

### 应用
$O(n)$时间的*有根树同构*算法思路：
1. 基于编码实现
2. 初始令所有的叶子节点的编码为"01"
3. 设某一内部节点的孩子均已经编码完毕
4. 对孩子们的编码**做字典序列排序，并按需拼接成一个新的串$S'$**
5. 当前节点的编码就是$0S'1$
6. 向上回溯，最终树的编码就是根节点的编码
7. 编码相同的树是同构的

这个过程就很适合基数排序

无根树同构其实也是编码，不过是另一种

## 基于比较的排序时间下界

这个下界说明的是
- **基于比较的**
- **正确的排序算法**
- **在最坏情况下的**

时间下界

由于正确的排序判定树的节点数目不少于$n!$个，因此排序树的最小树高为$\log(n!) = \Omega(n\log n)$

## 快速排序的平均性能
算法略。

分析思路：
1. 构造指示器随机变量$X_{ij} = I\{z_i与z_j比较\}$
2. 写出总比较次数$X = \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} X_{ij}$
3. 利用期望的线性性和指示器函数的期望性质，写出$X$的期望表达式
   
   $$
    E[X] = \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} E[X_{ij}] 
   = \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} Pr\{z_i与z_j比较\}
   $$
4. 根据独立假设和互斥条件，写出$Pr = 2/{j-i+1}$
5. 代入上式，换元放缩得$E[X] = \sum_{i=1}^{n-1}\sum_{k=1}^{n-i} 2/(k+1) < \sum_{i=1}^{n-1}\sum_{k=1}^{n-i} 2/k$
6. 根据调和级数的渐进界得$E[X] = \sum_{i=1}^{n-1}O(lgn) = O(nlgn)$

平均性能分析：

## 堆排序

大根堆为例
```
insert(x):
    insert to the end
    while x != root and x > fa[x]:
        swap(x, x.fa)

extract_max():
    swap(root, end)
    x = root
    while (x < x.lson or x < x.rson):
        max_son = max(x.lson, x.rson)
        swap(x, max_son)

build():
    apply heapify at node 1 to n/2
```

## 希尔排序
```
for step = n/2 to 1:
    按step步长做插入排序
```

## 红黑树
### 红黑树性质
1. 每个节点不是红的就是黑的
2. 根节点是黑的
3. 每个叶子节点都是NIL（空节点），且都是黑的
4. 红节点的孩子都是黑的
5. 对任意节点，从该节点到任意叶子的路径上都有相同个数的黑节点

其中最重要的是性质4和5

### 时间性能分析
$n$个内部节点的红黑树高至多是$2\lg(n+1)$

证明思路：
1. 记$bh(x)$为黑高度，表示$x$到根节点的路径上的黑色节点数减1
2. 归纳法可证以$x$为根的子树至少含$2^{bh(x)-1}$个节点
3. 由红黑树性质4可知任何一条到叶节点的路径上黑节点的数目都超过路径上节点数目的一半，从而$2bh(x) \ge h(x)$，从而$h \le 2lg(n+1)$

### 插入操作
插入节点初始为红色，因此有可能破坏的性质只有4（当插入节点和父亲节点都是红的的时候）
两大类：
- 红叔
  
  只染色。染色，然后指针上浮，继续修复

- 黑叔
  
  需要旋转。

  调整结构，然后染色，红红双旋转。

  旋转完，修复结束

**最后， 将根节点置为黑色**

总的来说至多只需要一个双旋。但染色可能递归到根，注意无论哪种情况都要维护根节点颜色。

### 删除操作

如果被删除节点是红色的，则不会破坏任何性质；反之，若被删除节点是黑色的，则可能破坏性质4和5

停止调整的条件是到达根节点或$x$节点为红色

- 红兄
  
  单旋转换为黑兄

- 黑兄，黑侄
  
  染色，上浮指针

- 黑兄，红侄
  
  调整红侄到zig-zig结构，然后旋转染色让左侧多出一个黑节点，结束

收尾同样是令$x$为红色

## BST随机建树的平均树高

思路：构建关于平均路径长度$P(n)$的递推关系，然后应用归纳法

## 哈希表
### 解决冲突
- 链接法
  
  一次查找、插入的时间都是$O(1+\alpha)$

- 开地址法
  
  一次不成功的查找，以及插入的时间是$O(1/(1-\alpha))$

  一次成功的查找的时间是$O(\frac{1}{\alpha}\ln\frac{1}{\alpha} + \frac{1}{\alpha})$
### 散列函数
- 简单均匀散列：每个关键字落在每个入口的可能性相等
- 除法散列
  
  $$
    h(k) = k mod m
  $$

- 乘法散列
  
  $$
    h(k) = \lfloor m(kA mod 1) \rfloor
  $$

  其中$A \in (0, 1)$

- *全域散列

### 探查方法
带探查的哈希函数：$h(k, i)$
- 线性探查
  
  $$
  h(k, i) = (h'(k) + i) mod m
  $$

- 二次探查
  
  $$
    h(k, i) = (h'(k) + C_1 i + C_2 i^2) mod m
  $$

- 双哈希
  
  $$
    h(k, i) = (h_1(k) + i \cdot h_2(k)) mod m
  $$

## 启发式合并
时间$O(n\log n)$

分析思路：**在整个合并过程中，若一个元素若被移动$k$次，则其所在集合的大小至少为$2^k$**，由此可知$k$至多为$\log n$级别，乘以元素个数就是上界。

## 递归式分析

三个方法：
- 主定理
- 猜解法（还是归纳）
- 归纳法
- 代换

### 主定理
对于递归式$T(n) = aT(n/b) + f(n)$

有：
1. $f(n) = \Theta(n^{\log_b a})$，则$T(n) = \Theta(n^{\log_b a} \log n)$
2. “f(n)<齐次项”， $f(n) = O(n^{\log_b a - \epsilon})$，则$T(n) = \Theta(n^{\log_b a})$
2. “f(n)>齐次项”
   
   处理基本的“多项式意义上大于”之外：
   
   $$f(n) = O(n^{\log_b a - \epsilon})$$

   还要检查正则化条件：
   $$
    af(n/b) \le cf(n)
   $$
   对$c<1$和充分大的$n$成立
   
   则$T(n) = \Theta(f(n))$