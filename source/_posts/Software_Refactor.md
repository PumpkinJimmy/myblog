---
abbrlink: '0'
title: 《重构的时机与方法》读书笔记
---
# 《重构的时机与方法》读书笔记
## 重构的基本方法论和理念
- 不应该重构的情况
  - *性能敏感的代码*
  - 一次性代码
  - 即将停用的代码
- 可读性
  - 代码能直接传达意图的特性
  - “不可读”意味着不能很快地通过函数名/变量名理解意图
  - 代码不可读会来自于不充分的自描述，比如使用大量低级原语（比如四则运算、数组索引）
- 可维护性
  - *维护*：对于存量代码，无论是修复缺陷还是扩展功能，我们都需要评估“代码的增加/修改应该放在哪一个上下文中”
  - 评估代码修改应该所处的上下文意味着“维护的成本是需要阅读理解的关联代码长度”
  - 因此可维护性的定性的度量标准是，*维护者需要Review多少相关代码才能有信心地作出修改*
- 规则
  - 针对代码的要求，比如“一个函数不超过5行”
  - “代码异味”
    - 作为识别“坏的代码”的直觉或者说经验
    - 规则是系统化表征代码异味的工具
  - 一旦违反，我们可以将给定函数作为重构目标
  - 一旦识别到违反的规则，可以去匹配相关的*重构模式*
- 重构模式
  - 一组源码操作的模式，依照套路可以在不改变代码行为的前提下重构代码以处理对规则的违反，比如“提取函数”
- 重构的要点
  - 提高代码的可读性
  - 提高代码的可维护性
  - 在不修改软件行为的前提下达成上述目标
- 重构的基本流程
  1. 选择一个重构目标（比如一个类的方法）
  2. 检查该目标是否破坏了规则
  3. 若是，匹配规则对应的重构模式，执行重构


## chapter 3. 拆分长函数
本章节聚焦同一个方法内部的一些基本规则和重构

- 理念：一个函数只干一件事
  - 这个理念最有争议的点就是“怎么算作一件事”
  - 这本书的不少规则以非常具体的方式界定了“一件事”，使得这个理念能得到更好的落实

- 规则：分解函数以平衡抽象
  - 具体描述：同一个方法中，使用一个实例时，要么只使用实力的方法，要么只将实例作为参数传递
  - 背后的意图是“函数的内容应该在同一个级别的抽象上”
  - 很有意思的规则，通过区分这种使用语法背后暗示抽象层级区别来试图保证封装良好
    - 将实例当作参数传递时通常意味着我们将它作为一个整体来使用，此时不关心实例的状态，不应该使用点记号访问其方法
    - 反之亦然，只不过实践中可能没那么僵化

- 理念：组合优于继承
  - 属于陈词滥调了
  - 主要看点：原来主流的重构观点确实是通过“继承Interface + 委托”的范式来实现组合。
  - 这意味着现代的继承语法已经甩掉了“公有继承等于is-a关系”的观点，而是专注于接口本身
  - 这意味着为了给Vehicle增加Wheel的服务，让Vehicle继承IWheel接口然后再委托给Wheel类的做法是可以接受的
    - 虽然我还是感觉不太符合直觉，可能是`IWheel`的命名不恰当

- 规则：只在最开始使用if
  - 认为即便是校验一下参数的if也是做了一件事，根据“一个函数只干一件事”的理念，if没放开头就暗示了函数包含多于一件事
  - 工程实践中有点过于苛刻了
    - 比如校验参数的if改为assert断言，实际操作中我们肯定不希望把各种鸡毛蒜皮的小异常都抛到上层让程序频繁崩溃
      - 注意到良好的封装的其中一个要求是能够正确消化掉（处理掉）一些上层不关心的异常
    - 结果就是要么频繁使用try来处理异常（非常丑陋且低效），要么非得使用if来打印异常日志并返回上层（使用Asset实现不了在不抛出异常的情况下终止函数执行）
    - 不过实际上，很多校验如果失败的话，函数其实是执行不下去，此时用if和用throw的区别无非是：是否会中断上层调用方法的流程
      - 如果上层方法依赖这个方法的结果，那这个结果不存在也变相中止了上层方法的流程，此时抛出异常没有问题
      - 如果上层方法不依赖这个方法的结果，那抛出异常不合适
      - 思考：如果我在“不关心这个方法的结果”的一层上加try是不是兼顾了两种情况？既不用层层校验（通过异常的退栈来跳出），也不用可以做到模块内部正确处理异常
      - 比如说，我们总是在public方法这一层设置try，保证其他模块使用时能无视掉模块内部的一些异常
    - 还有，在不考虑多条件分支的情况下，这个规则相当于将所有方法的圈复杂度锁定为1，这个通常没必要

- 思考：相比C++，C#的泛型语法更规范更安全更受限，但代价有些zero-cost abstraction无法实现了
  - 比如，如果我有一个编译时写死的Strategy列表需要使用
    - C++支持可变参数模板，将Strategy类数组写入可变参数模板中，然后展开之后不需要任何虚函数、多态和额外内存分配了
    - C#不支持可变参数模板，编译时确定的东西不得不使用动态派发，也即一个`IStrategy`实例数组，而且依赖单例模式（享元模式）来避免大量GC

## chapter 4. 使用类型系统
- 理念：扩展优于修改
  - 在我们试图编写业务代码时，能不改动老的代码总是最好的，这样最大程度降低重新测试的成本和改动现有功能的风险
  - 这意味着我们需要仅通过增加代码来增加行为，减少硬编码
  - 不仅是避免硬编码数据，而且是避免硬编码决策逻辑（见后面）

- 规则：只使用一个if
  - 意图：保证一个函数只做一件事情
  - 跟圈复杂度有些关联
- 规则：从不使用else
  - 意图：避免“硬编码决策逻辑”
  - 书中只将if当作一种检查语句来使用，认为if-else联用是“硬编码了决策”从而方案了后续扩展
  - 解决策略：将if一律改成多态，总是通过动态派发来解耦决策
    - 显然，如果全部改动态派发，马上会新增一堆new操作和虚函数访问
    - 优化虚函数：改静态派发。因为绝大多数多态都是静态的（我们仅根据不同的代码上下文就能在编译期决策我们或落实哪个行为）
    - 优化new操作：
      - 对象池模式/单例模式
      - 动态派发可能是不可避免的。比如我们的行为以来输入或者运行时上下文；或者我们需要容器化遍历实例并执行多态，这种派发只有在C++中用复杂的设施才能改成静态派发
      - 此时，我们用于避免硬编码决策逻辑的类通常是Strategy，这种类没有实际状态（其实底层只是等效一个函数指针 + 它的虚表），所以可以做成单例对象一次创建全局使用。代价是代码可能变得复杂冗长
  - 效果：对于给定模块，通过派发，我们可以修改传入的实参而不修改模块本身来改变模块的行为

- 规则：从不使用switch
  - 动机类似从不使用else的延续
  - 规则的例外是：仅在每个case都返回，且没有（有效的）default的情况下可以接受
  - 不能有default的原因是：一旦输入新增，switch没有同步修改，则编译器不会提示，这个异常会被延迟到运行时才发现，这不是理想的代码结构
  - switch的另一个坏处是：容易忘掉break（这个其实IDE和编译器都可以解决，但不应该依赖此）

- 重构模式：去除泛化
  - 将一些通用方法拆分回特定情况的代码，哪怕代码有重复
  - 这个模式比较反直觉，可以让可以（至少部分）重用的代码变成重复代码，一般是跟其他模式组合使用的

- 规则：仅从接口继承
  - 这意味着*禁止从类或者抽象类继承”
  - 理由是：从类/抽象类继承的主要动机是通过让某个方法拥有默认实现来避免重复编码
  - 问题：这种代码共享会导致耦合
  - 解决策略通常是使用Strategy模式抽出共享代码

## chapter 5. 提取相似类
- 规则：if语句不应该有副作用
  - 与其说是规则不如说是理念。因为现在使用有副作用的if的语法糖已经很普遍了。C#中的`out`参数在减少了编码量的同时确保了可读性
  - 但这个理念还是有价值的：凡是类似`Check, Can, Assert`这种只用来判断的方法，就应该约定它们其中不包含副作用
  - 一个推向极端的版本：函数要么有返回值且无副作用（函数式中的Pure Function），要么无返回值而有副作用（Monad）

## chapter 6. 保护数据
- 规则：从不提供getter/setter
  - 动机：按照理念“不与陌生人说话”，认为即便有了Getter的封装来保护数据依然是不够的。正确使用private的方法是：把所有用到Getter的代码迁移到类里面
  - 解决方法：使用重构模式Push Code Into Class（代码迁移到类中，见下）
  - 一个有意思的观察：一般Getter/Setter式的代码会暗示了“拉”模式的架构，而去除之后会演变成“推”模式的架构
    - 实践中其实这两种模式各有优劣的
    - 推模式
      - 推模式往往让类的通用性下降。如果要在使用推模式的同时避免频繁修改类的实现，意味着类本身需要使用很多Strategy模式避免硬编码
    - 拉模式
      - 拉模式很多时候能减少编码，将Getter类看作一个共享数据结构，当然这确实带来了一些耦合

- 重构模式：代码迁移到类中
  - 将某些代码从类外部迁移到类中，非常笼统的做法
  - 这个模式的意义在于，实践中就是有很多代码放类外或者类内都是可行的。这个模式的存在暗示了，我们在重构中可以完全不改变逻辑的情况下执行这个代码迁移的操作，至于何时迁移如何迁移，则取决于我们的规则
  - 更具体地说，代码放在类外还是类内，从编码角度都是可等效实现的，但放在不同的位置意味着不同的架构设计，所以这是架构设计的决策点

- 规则：从不出现相同前后缀
  - 如果成员/方法的良好命名中，出现了共享前缀/后缀（比如`playerPos, playerType`，或者`tranformMap, updateMap`），则需要抽取出单独的类
  - 动机是显然的，而其中一个就是保护数据，让状态更加局部化
  - 通常将这种对成员/方法进行进一步封装的重构模式叫做Encapsulate Data（封装数据）
  - 另一个好处是这帮助我们定义什么叫做“一个类只能有一个职责”：当我们有一组方法是共享前后缀的时候，往往意味着当前类已经有多个职责了

- 规则：强制时序
  - 如果方法存在某种时序依赖，借助编译器设施（比如语言提供的构造函数）强制这种时序生效
  - 这种思想其实是通过构造函数这种特殊语言设施告知编译器我们的代码运行方式，最终让编译器来保证代码的正确性
  - 实际使用中的局限包括对象池（不能使用构造函数）以及框架限制（Unity的Mono）以及性能优化（比如异步创建）

## 完本随笔
- 其实纵观全书，很多“代码异味”的识别以及它们的重构模式，对于开发者来说都是自然的（不言自明的）
- 这本书对我最有价值的地方在于：
  1. 明确了代码可维护性、代码可读性的具体含义，这有助于我自己思考编写真正的“可维护”代码而不是简单地滥用抽象和代码复用
  2. 以可定性甚至可定量的方式描述了某些我们直觉上意识到的代码异味，比如“5行法则”，“单if法则”，“无else法则”，“无Getter法则” 
  3. 以非常明确的模板操作/模板代码进一步厘清了设计模式的合理实现，比如策略模式的实现、组合的实现
  4. 帮助我意识到编码中有很多从编码角度是等效的但从设计角度不等效的情形，这些情形正是所谓代码架构的决策点
  5. 明确了抽象的目的往往是可扩展性、可维护性、可复用性，而代价是性能，因此C++的“零开销抽象”才如此的独特：如果我们既想通过抽象来支撑大型工程，又不想为此支付overhead，那C++几乎是唯一的选择
  6. 整理了一些平时我零散的软件工程理念
- 全书的一些设计理念
  - 可维护性高意味着我们只需要研究很少的上下文就能维护/扩展一个模块
  - 可读性意味着代码是自描述的，我们容易从代码书写中理解代码意图
  - 抽象是通过提高实际的复杂度（增加编码、类、方法）来降低理解复杂度的过程
  - 一个方法只干一件事，一个类只有一个职责
  - 扩展优于修改
  - “不与陌生人说话”（数据保护）
- 工程实践的无奈
  - 以下几个问题限制了我产出完全没有“代码异味”的优质代码
    - 频繁变更的需求 + 有限的时间：不会有充足的时间为需求搭建框架/重构代码
    - 敏感的性能要求：游戏的绝大部分运行时代码都运行在Update中，如果要求全程流畅，那整个系统的所有代码都是性能敏感的：每次Update不超过16ms
  - 性能优化会牺牲掉代码的重构能力
    - 这也是所谓“不要过早优化”理念的动机之一
    - 类似普遍的“对象池”设计限制了我们使用更安全的构造/析构函数来保证时序安全
  - 框架也限制了我们写出可维护的代码
    - Unity引擎要求在主线程使用其API，导致无法在析构函数释放Unity资源
    - 虽然我们仍然可以使用Mono的`OnDestroy`，但此法将类的声明周期绑定在了Unity GameObject上了，限制了我满足其他需求（比如对象池，比如Prefab异步）
    - 我们可以自定义`OnRelease`然后约定在销毁时手动调用，但这样我们失去了编译器的帮助（没有强制这个时序，没有编译报错），一旦“忘记”就会出bug
  - 对模块稳定性的要求
    - 这意味着我们不能轻易抛出异常导致崩溃，而是尽可能隐藏一些不致命的异常，虽然这会导致更多问题